---
import { render, type CollectionEntry } from "astro:content";
import Layout from "@/layouts/Layout.astro";
import Header from "@/components/Header.astro";
import Footer from "@/components/Footer.astro";
import Tag from "@/components/Tag.astro";
import Datetime from "@/components/Datetime.astro";
import EditPost from "@/components/EditPost.astro";
import BackButton from "@/components/BackButton.astro";
import BackToTopButton from "@/components/BackToTopButton.astro";
import { getPath } from "@/utils/getPath";
import { slugifyStr } from "@/utils/slugify";
import IconChevronLeft from "@/assets/icons/IconChevronLeft.svg";
import IconChevronRight from "@/assets/icons/IconChevronRight.svg";
import IconMenuDeep from "@/assets/icons/IconMenuDeep.svg";
import IconX from "@/assets/icons/IconX.svg";
import { SITE } from "@/config";

export interface Props {
  post: CollectionEntry<"blog">;
  posts: CollectionEntry<"blog">[];
}

const { post, posts } = Astro.props;

const {
  title,
  author,
  description,
  ogImage: initOgImage,
  canonicalURL,
  pubDatetime,
  modDatetime,
  timezone,
  tags,
  hideEditPost,
} = post.data;

const { Content } = await render(post);

let ogImageUrl: string | undefined;

// Determine OG image source
if (typeof initOgImage === "string") {
  ogImageUrl = initOgImage; // Remote OG image (absolute URL)
} else if (initOgImage?.src) {
  ogImageUrl = initOgImage.src; // Local asset
}

// Use dynamic OG image if enabled and no remote|local ogImage
if (!ogImageUrl && SITE.dynamicOgImage) {
  ogImageUrl = `${getPath(post.id, post.filePath)}/index.png`;
}

// Resolve OG image URL (or fallback to SITE.ogImage / default `og.png`)
const ogImage = ogImageUrl
  ? new URL(ogImageUrl, Astro.url.origin).href
  : undefined;

const layoutProps = {
  title: `${title} | ${SITE.title}`,
  author,
  description,
  pubDatetime,
  modDatetime,
  canonicalURL,
  ogImage,
  scrollSmooth: false,
};

/* ========== Prev/Next Posts ========== */

const allPosts = posts.map(({ data: { title }, id, filePath }) => ({
  id,
  title,
  filePath,
}));

const currentPostIndex = allPosts.findIndex(a => a.id === post.id);

const prevPost = currentPostIndex !== 0 ? allPosts[currentPostIndex - 1] : null;
const nextPost =
  currentPostIndex !== allPosts.length ? allPosts[currentPostIndex + 1] : null;
---

<Layout {...layoutProps}>
  <Header />
  <BackButton />

  <style>
    :root {
      --toc-width: 20%;
    }

    @media (min-width: 1230px) {
      :root {
        --toc-width: 25%;
      }
    }

    @media (min-width: 1500px) {
      :root {
        --toc-width: 30%;
      }
    }

    /* Hide desktop TOC and show mobile hamburger below lg (1024px) */
    @media (max-width: 1023px) {
      #post-toc-desktop {
        display: none !important;
      }

      #toc-desktop-toggle {
        display: none !important;
      }

      #main-content {
        padding-left: 1rem !important;
      }
    }

    /* Show desktop TOC and hide mobile hamburger at lg (1024px) and above */
    @media (min-width: 1024px) {
      #menu-btn {
        display: none !important;
      }
    }
  </style>
  <!-- Desktop TOC toggle button and fixed nav - Only visible on desktop (lg+) -->
  <button
    id="toc-desktop-toggle"
    class="fixed top-6 left-3 z-30 size-10 items-center justify-center lg:flex"
    aria-controls="post-toc-desktop"
    aria-expanded="true"
    title="Toggle contents"
  >
    <IconMenuDeep id="toc-open-icon" class="hidden" />
    <IconX id="toc-close-icon" />
  </button>
  <nav
    id="post-toc-desktop"
    class="fixed inset-y-0 left-0 z-20 hidden h-dvh max-w-[23rem] overflow-y-auto bg-background px-6 pt-32 lg:block"
    style="width: var(--toc-width, 20%);"
    aria-label="Table of contents"
  >
    <h2 class="mb-4 text-2xl font-semibold">Contents</h2>
    <ul id="toc-list-desktop" class="space-y-2 pt-4 pb-8"></ul>
  </nav>

  <!-- Mobile TOC overlay (below header, full height minus header) -->
  <nav
    id="post-toc-mobile"
    class="fixed inset-x-0 bottom-0 z-40 hidden overflow-y-auto bg-background pt-4 sm:pt-8 lg:hidden"
    aria-label="Table of contents"
  >
    <div class="mx-auto max-w-app px-4 py-4">
      <h2 class="mb-4 text-2xl font-semibold">Contents</h2>
      <ul id="toc-list-mobile" class="list-none space-y-2 pl-0"></ul>
    </div>
  </nav>
  <main
    id="main-content"
    class:list={[
      "mx-auto w-full max-w-app px-4 pb-12",
      { "mt-8 sm:mt-12": !SITE.showBackButton },
    ]}
    data-pagefind-body
  >
    <h1
      transition:name={slugifyStr(title)}
      class="inline-block text-5xl font-bold text-accent lg:text-[64px]"
    >
      {title}
    </h1>
    <div class="mt-9 mb-0 flex items-center gap-2">
      <Datetime
        {pubDatetime}
        {modDatetime}
        {timezone}
        showIcon={false}
        showUpdatedLabel={false}
        preferPublished={true}
        size="lg"
      />
    </div>
    <article
      id="article"
      class="app-prose mx-auto mt-5 max-w-app prose-pre:bg-(--shiki-light-bg) dark:prose-pre:bg-(--shiki-dark-bg)"
    >
      <Content />
    </article>

    <hr class="my-8 border-dashed" />

    <EditPost class="sm:hidden" {hideEditPost} {post} />

    <div class="mt-4 mb-8 flex items-center gap-4 sm:my-8">
      <ul class="flex flex-1 flex-wrap gap-2">
        {tags.map(tag => <Tag tag={slugifyStr(tag)} tagName={tag} />)}
      </ul>
      <div class="flex-shrink-0">
        <BackToTopButton />
      </div>
    </div>

    <hr class="my-6 border-dashed" />

    <!-- Previous/Next Post Buttons -->
    <div data-pagefind-ignore class="grid grid-cols-1 gap-6 sm:grid-cols-2">
      {
        prevPost && (
          <a
            href={getPath(prevPost.id, prevPost.filePath)}
            class="flex w-full gap-1 hover:opacity-75"
          >
            <IconChevronLeft class="inline-block flex-none rtl:rotate-180" />
            <div>
              <span>Previous Post</span>
              <div class="text-sm text-accent/85">{prevPost.title}</div>
            </div>
          </a>
        )
      }
      {
        nextPost && (
          <a
            href={getPath(nextPost.id, nextPost.filePath)}
            class="flex w-full justify-end gap-1 text-end hover:opacity-75 sm:col-start-2"
          >
            <div>
              <span>Next Post</span>
              <div class="text-sm text-accent/85">{nextPost.title}</div>
            </div>
            <IconChevronRight class="inline-block flex-none rtl:rotate-180" />
          </a>
        )
      }
    </div>
  </main>
  <Footer />
</Layout>

<script is:inline data-astro-rerun>
  /** Attaches links to headings in the document,
   *  allowing sharing of sections easily */
  function addHeadingLinks() {
    const headings = Array.from(
      document.querySelectorAll(
        "article h2, article h3, article h4, article h5, article h6"
      )
    );
    for (const heading of headings) {
      // Only add links to headings that have an ID
      if (!heading.id) continue;

      heading.classList.add("group");
      const link = document.createElement("a");
      link.className =
        "heading-link ms-2 no-underline opacity-75 md:opacity-0 md:group-hover:opacity-100 md:focus:opacity-100";
      link.href = "#" + heading.id;

      const span = document.createElement("span");
      span.ariaHidden = "true";
      span.innerText = "#";
      link.appendChild(span);
      heading.appendChild(link);
    }
  }
  addHeadingLinks();

  /** Attaches copy buttons to code blocks in the document,
   * allowing users to copy code easily. */
  function attachCopyButtons() {
    const copyButtonLabel = "Copy";
    const codeBlocks = Array.from(document.querySelectorAll("pre"));

    for (const codeBlock of codeBlocks) {
      const wrapper = document.createElement("div");
      wrapper.style.position = "relative";

      // Check if --file-name-offset custom property exists
      const computedStyle = getComputedStyle(codeBlock);
      const hasFileNameOffset =
        computedStyle.getPropertyValue("--file-name-offset").trim() !== "";

      // Determine the top positioning class
      const topClass = hasFileNameOffset
        ? "top-(--file-name-offset)"
        : "-top-3";

      const copyButton = document.createElement("button");
      copyButton.className = `copy-code absolute end-3 ${topClass} rounded bg-muted border border-muted px-2 py-1 text-xs leading-4 text-foreground font-medium`;
      copyButton.innerHTML = copyButtonLabel;
      codeBlock.setAttribute("tabindex", "0");
      codeBlock.appendChild(copyButton);

      // wrap codebock with relative parent element
      codeBlock?.parentNode?.insertBefore(wrapper, codeBlock);
      wrapper.appendChild(codeBlock);

      copyButton.addEventListener("click", async () => {
        await copyCode(codeBlock, copyButton);
      });
    }

    async function copyCode(block, button) {
      const code = block.querySelector("code");
      const text = code?.innerText;

      await navigator.clipboard.writeText(text ?? "");

      // visual feedback that task is completed
      button.innerText = "Copied";

      setTimeout(() => {
        button.innerText = copyButtonLabel;
      }, 700);
    }
  }
  attachCopyButtons();

  /** Attaches tooltips to footnote references */
  function attachFootnoteTooltips() {
    // First, remove any existing tooltips to prevent duplicates
    document.querySelectorAll(".footnote-tooltip").forEach(tooltip => {
      tooltip.remove();
    });

    const footnoteRefs = document.querySelectorAll(
      "sup a[data-footnote-ref], sup[data-footnote-ref] a"
    );

    footnoteRefs.forEach(ref => {
      const supElement = ref.closest("sup");
      if (!supElement) return;

      // Skip if this sup already has a tooltip (extra safety check)
      if (supElement.querySelector(".footnote-tooltip")) return;

      // Get the footnote ID from the href
      const footnoteId = ref.getAttribute("href")?.replace("#", "");
      if (!footnoteId) return;

      // Find the corresponding footnote content
      const footnoteElement = document.getElementById(footnoteId);
      if (!footnoteElement) return;

      // Get the footnote text (excluding the backref link)
      const footnoteContent = footnoteElement.cloneNode(true);
      const backref = footnoteContent.querySelector("[data-footnote-backref]");
      if (backref) backref.remove();

      // Create tooltip element
      const tooltip = document.createElement("div");
      tooltip.className = "footnote-tooltip";

      // Get the footnote number from the ref text
      const footnoteNumber = ref.textContent.trim();

      // Create the tooltip content with footnote number at the start
      tooltip.innerHTML = `<sup>${footnoteNumber}</sup> ${footnoteContent.innerHTML.trim()}`;

      // Make the sup element relative positioned for tooltip
      supElement.style.position = "relative";
      supElement.appendChild(tooltip);

      // Show tooltip on hover
      ref.addEventListener("mouseenter", () => {
        tooltip.classList.add("show");
      });

      ref.addEventListener("mouseleave", () => {
        tooltip.classList.remove("show");
      });

      // Also handle touch for mobile
      ref.addEventListener("click", () => {
        // Allow the link to work but also show tooltip briefly
        tooltip.classList.add("show");
        setTimeout(() => {
          tooltip.classList.remove("show");
        }, 2000);
      });
    });
  }
  attachFootnoteTooltips();

  /* Go to page start after page swap */
  document.addEventListener("astro:after-swap", () => {
    window.scrollTo({ left: 0, top: 0, behavior: "instant" });
    attachFootnoteTooltips(); // Re-attach tooltips after navigation
  });

  // Build and wire up TOC for mobile and desktop
  function bindDesktopTocToggle(
    desktopToggle,
    desktopNav,
    desktopOpenIcon,
    desktopCloseIcon
  ) {
    if (!desktopToggle || !desktopNav) return;
    // Avoid binding multiple times across navigations
    if (desktopToggle.dataset.bound === "true") return;

    desktopToggle.addEventListener("click", () => {
      const isVisible = !desktopNav.classList.contains("!hidden");
      if (isVisible) {
        // Hide the nav
        desktopNav.classList.add("!hidden");
        desktopOpenIcon?.classList.remove("hidden");
        desktopCloseIcon?.classList.add("hidden");
        desktopToggle.setAttribute("aria-expanded", "false");
      } else {
        // Show the nav
        desktopNav.classList.remove("!hidden");
        desktopOpenIcon?.classList.add("hidden");
        desktopCloseIcon?.classList.remove("hidden");
        desktopToggle.setAttribute("aria-expanded", "true");
      }
    });

    desktopToggle.dataset.bound = "true";
  }

  function setupPostToc() {
    const mobileNav = document.querySelector("#post-toc-mobile");
    const mobileList = document.querySelector("#toc-list-mobile");
    const desktopNav = document.querySelector("#post-toc-desktop");
    const desktopList = document.querySelector("#toc-list-desktop");
    const desktopToggle = document.querySelector("#toc-desktop-toggle");
    const desktopOpenIcon = document.querySelector("#toc-open-icon");
    const desktopCloseIcon = document.querySelector("#toc-close-icon");

    const headerEl = document.querySelector("#site-header");
    const headerBtn = document.querySelector("#menu-btn");

    // Always attempt to bind the desktop toggle if elements exist
    bindDesktopTocToggle(
      desktopToggle,
      desktopNav,
      desktopOpenIcon,
      desktopCloseIcon
    );

    if (!mobileNav || !mobileList || !desktopNav || !desktopList) return;

    // Position mobile panel below header
    if (headerEl) {
      const rect = headerEl.getBoundingClientRect();
      mobileNav.style.top = `${rect.height}px`;
    }

    // Collect headings, but exclude hidden/sr-only footnotes label
    const headingNodes = Array.from(
      document.querySelectorAll(
        "article h2, article h3, article h4, article h5, article h6"
      )
    ).filter(
      el => !(el.id === "footnote-label" || el.classList.contains("sr-only"))
    );

    mobileList.innerHTML = "";
    desktopList.innerHTML = "";

    if (headingNodes.length === 0) {
      // Hide both desktop and mobile toggles when no headings
      if (desktopToggle) {
        desktopToggle.classList.add("!hidden");
      }
      if (headerBtn) {
        headerBtn.classList.add("!hidden");
      }
      // Also hide the desktop nav
      if (desktopNav) {
        desktopNav.classList.add("!hidden");
      }
      return;
    }

    // Remove force-hidden class if headings exist
    if (desktopToggle) {
      desktopToggle.classList.remove("!hidden");
    }
    if (headerBtn) {
      headerBtn.classList.remove("!hidden");
    }
    if (desktopNav) {
      desktopNav.classList.remove("!hidden");
    }

    document.documentElement.style.scrollBehavior = "auto";

    function stripHash(text) {
      return text?.replace(/#\s*$/, "").trim();
    }

    function createLI(id, text) {
      const li = document.createElement("li");
      const a = document.createElement("a");
      a.href = `#${id}`;
      a.textContent = stripHash(text);
      a.className =
        "block rounded py-1 text-xl font-normal opacity-50 hover:opacity-30";
      a.addEventListener("click", e => {
        e.preventDefault();
        const target = document.getElementById(id);
        // Close mobile if open
        if (!mobileNav.classList.contains("hidden")) {
          mobileNav.classList.add("hidden");
          const mi = document.querySelector("#menu-icon");
          const ci = document.querySelector("#close-icon");
          mi?.classList.remove("hidden");
          ci?.classList.add("hidden");
          headerBtn?.setAttribute("aria-expanded", "false");
        }
        if (target) {
          target.scrollIntoView({ behavior: "auto", block: "start" });
          history.replaceState(null, "", `#${id}`);
        } else {
          location.hash = `#${id}`;
        }
      });
      li.appendChild(a);
      return li;
    }

    const headings = headingNodes.filter(h => h.id);
    for (const h of headings) {
      const text = h.textContent || h.id;
      mobileList.appendChild(createLI(h.id, text));
      desktopList.appendChild(createLI(h.id, text));
    }

    // Desktop toggle binding handled above via bindDesktopTocToggle

    // Improved scroll spy with better detection
    let currentActive = "";

    function updateActiveSection() {
      const scrollY = window.scrollY;
      const windowHeight = window.innerHeight;

      let newActive = "";

      // Find the heading that's currently most visible
      for (let i = 0; i < headings.length; i++) {
        const heading = headings[i];
        const rect = heading.getBoundingClientRect();
        const headingTop = scrollY + rect.top;

        // Check if we're past this heading
        if (scrollY + windowHeight * 0.3 >= headingTop) {
          newActive = heading.id;
        } else {
          break;
        }
      }

      // Only activate first heading if we're actually close to it
      if (headings.length > 0) {
        const firstHeading = headings[0];
        const firstRect = firstHeading.getBoundingClientRect();
        const firstHeadingTop = scrollY + firstRect.top;

        // If we're above the first heading by more than a reasonable distance, don't activate anything
        if (scrollY + windowHeight * 0.3 < firstHeadingTop - 200) {
          newActive = "";
        }
      }

      if (newActive !== currentActive) {
        currentActive = newActive;

        // Update styles for both mobile and desktop
        for (const list of [mobileList, desktopList]) {
          const links = list.querySelectorAll("a");
          links.forEach(a => {
            const isActive = a.getAttribute("href") === `#${currentActive}`;
            if (isActive) {
              a.className =
                "block rounded py-1 text-xl font-normal opacity-100 hover:opacity-75";
            } else {
              a.className =
                "block rounded py-1 text-xl font-normal opacity-50 hover:opacity-30";
            }
          });
        }
      }
    }

    // Use scroll event for more responsive updates
    let scrollTimeout;
    window.addEventListener("scroll", () => {
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      scrollTimeout = setTimeout(updateActiveSection, 10);
    });

    // Initial update
    updateActiveSection();
  }
  setupPostToc();
  document.addEventListener("astro:page-load", () => {
    setupPostToc();
    attachFootnoteTooltips(); // Attach tooltips on page load
  });
  document.addEventListener("astro:after-swap", setupPostToc);
</script>
